"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOffchainClient = void 0;
const axios_1 = __importStar(require("axios"));
const private_actions_1 = require("./private-actions");
const public_actions_1 = require("./public-actions");
const dto_1 = require("../dto");
/** Backend URI mappings for different network modes */
const backendUris = {
    mainnet: "https://offchain-manager.namespace.ninja",
    sepolia: "https://staging.offchain-manager.namespace.ninja",
};
class HttpOffchainClient {
    constructor(config = {}) {
        this.config = config;
        this.apiKeys = {};
        this.fetchApiKeyForName = (name, isSubname = true) => {
            const extractParent = () => {
                const split = name.split(".");
                const splitLen = split.length;
                if (splitLen < 2) {
                    throw Error(`Invalid ENS name: ${name}`);
                }
                if (splitLen === 2) {
                    return name;
                }
                return split[splitLen - 2] + "." + split[splitLen - 1];
            };
            let parentName = isSubname ? extractParent() : name;
            if (this.apiKeys[parentName]) {
                return this.apiKeys[parentName];
            }
            if (this.defaultApiKey) {
                return this.defaultApiKey;
            }
            throw new Error(`Api key is not present for name: ${parentName}. Use setApiKey() or setDefaultApiKey() to configure authentication.`);
        };
        const mode = config.mode || "mainnet";
        const uri = config.backendUri || backendUris[mode];
        this.HTTP = axios_1.default.create({ ...this.config, baseURL: uri });
        // Initialize authentication from config if provided
        if (config.defaultApiKey) {
            this.setDefaultApiKey(config.defaultApiKey);
        }
        if (config.domainApiKeys) {
            for (const [ensName, apiKey] of Object.entries(config.domainApiKeys)) {
                this.setApiKey(ensName, apiKey);
            }
        }
    }
    async updateSubname(subname, request) {
        return (0, private_actions_1._updateSubname)(this.HTTP, this.fetchApiKeyForName(subname), subname, request);
    }
    async addAddressRecord(subname, chain, value) {
        const coin = (0, dto_1.getCoinType)(chain);
        if (coin === undefined) {
            throw Error(`Unsupported address: ${chain}`);
        }
        await (0, private_actions_1._addAddressRecord)(this.HTTP, this.fetchApiKeyForName(subname), subname, coin, value);
    }
    async deleteAddressRecord(subname, chain) {
        const coin = (0, dto_1.getCoinType)(chain);
        if (coin === undefined) {
            throw Error(`Unsupported address: ${chain}`);
        }
        await (0, private_actions_1._deleteAddressRecord)(this.HTTP, this.fetchApiKeyForName(subname), subname, coin);
    }
    async getSingleSubname(fullSubname) {
        try {
            return (0, public_actions_1._getSingleSubname)(this.HTTP, fullSubname);
        }
        catch (err) {
            if (err instanceof axios_1.AxiosError) {
                const axiosErr = err;
                if (axiosErr.response?.status === 404) {
                    return null;
                }
            }
            throw err;
        }
    }
    async getTextRecords(fullSubname) {
        return await (0, public_actions_1._getTextRecords)(this.HTTP, fullSubname);
    }
    async getTextRecord(fullSubname, key) {
        return await (0, public_actions_1._getTextRecord)(this.HTTP, fullSubname, key);
    }
    async getDataRecords(fullSubname) {
        return await (0, public_actions_1._getDataRecords)(this.HTTP, fullSubname);
    }
    async getDataRecord(fullSubname, key) {
        return await (0, public_actions_1._getDataRecord)(this.HTTP, fullSubname, key);
    }
    async isSubnameAvailable(fullSubname) {
        return await (0, public_actions_1._isSubnameAvailable)(this.HTTP, fullSubname);
    }
    async createSubname(request) {
        await (0, private_actions_1._createSubname)(this.HTTP, this.fetchApiKeyForName(request.parentName, false), request);
    }
    async deleteSubname(fullSubname) {
        await (0, private_actions_1._deleteSubname)(this.HTTP, this.fetchApiKeyForName(fullSubname), fullSubname);
    }
    async addTextRecord(subname, key, value) {
        await (0, private_actions_1._addTextRecord)(this.HTTP, this.fetchApiKeyForName(subname), subname, key, value);
    }
    async deleteTextRecord(fullSubname, key) {
        await (0, private_actions_1._deleteTextRecord)(this.HTTP, this.fetchApiKeyForName(fullSubname), fullSubname, key);
    }
    async addDataRecord(subname, key, value) {
        await (0, private_actions_1._addDataRecord)(this.HTTP, this.fetchApiKeyForName(subname), subname, key, value);
    }
    async deleteDataRecord(fullSubname, key) {
        await (0, private_actions_1._deleteDataRecord)(this.HTTP, this.fetchApiKeyForName(fullSubname), fullSubname, key);
    }
    async getFilteredSubnames(query) {
        return (0, public_actions_1._getFilteredSubnames)(this.HTTP, query);
    }
    setApiKey(ensName, apiKey) {
        this.apiKeys[ensName] = apiKey;
    }
    setDefaultApiKey(apiKey) {
        this.defaultApiKey = apiKey;
    }
}
/**
 * Create a new OffchainClient instance for managing ENS subnames.
 *
 * @param config - Optional configuration options including network mode, HTTP settings, and API keys
 * @returns A configured OffchainClient instance
 *
 * @example
 * ```typescript
 * import { createOffchainClient } from '@thenamespace/offchain-manager';
 *
 * // 1. No-arg initialization (defaults to mainnet)
 * const client = createOffchainClient();
 *
 * // 2. Configure network mode
 * const client = createOffchainClient({ mode: 'sepolia' });
 *
 * // 3. Initialize with address-based API key (works with all your ENS domains)
 * const client = createOffchainClient({
 *   mode: 'sepolia',
 *   defaultApiKey: 'your-address-based-api-key'
 * });
 *
 * // 4. Initialize with domain-based API keys (for specific ENS domains)
 * const client = createOffchainClient({
 *   mode: 'sepolia',
 *   domainApiKeys: {
 *     'example.eth': 'your-domain-based-api-key',
 *     'test.eth': 'another-domain-key'
 *   }
 * });
 *
 * // 5. Initialize with both default and domain API keys
 * const client = createOffchainClient({
 *   mode: 'sepolia',
 *   defaultApiKey: 'your-address-based-api-key',
 *   domainApiKeys: {
 *     'example.eth': 'your-domain-based-api-key'
 *   }
 * });
 *
 * // You can also set/update keys after initialization
 * client.setDefaultApiKey('your-api-key');
 * client.setApiKey('example.eth', 'your-domain-key');
 * ```
 */
const createOffchainClient = (config = {}) => {
    return new HttpOffchainClient(config);
};
exports.createOffchainClient = createOffchainClient;
